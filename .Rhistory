ggplot(aes(y = media_PIBpc, x = as.factor(vitoria_pp))) +
geom_col() +
theme_minimal() +
labs(title = "",
y = "PIB per capita",
x = "Prefeito do PP?")
g4 <- medias %>%
ggplot(aes(y = media_taxa_escolarizacao, x = as.factor(vitoria_pp))) +
geom_col() +
scale_y_continuous(labels = label_percent()) +
theme_minimal() +
labs(title = "",
y = "Taxa de escolarização",
x = "Prefeito do PP?")
g5 <- medias %>%
ggplot(aes(y = media_valor_empenhado, x = as.factor(vitoria_pp))) +
geom_col() +
theme_minimal() +
labs(title = "",
y = "Valor empenhado per capita",
x = "Prefeito do PP?")
graficos <- plot_grid(g1, g2, g3, g4, g5)
# plot_grid(titulo, graficos, ncol = 1, rel_heights = c(0.15, 1))
graficos
rm(medias, titulo, graficos, g1, g2, g3, g4, g5)
#| label: grafico_caracteristicas_municipais_por_razao_votos_pp
# Linear
g_pop <- dt_todas[pop %between% quantile(pop, c(.02, .99), na.rm = TRUE)] %>%
ggplot(aes(x = votos_razao_pp_centr, y = pop, color = as.factor(vitoria_pp))) +
geom_point(shape = 21, size = 0.5, color = "black") +
stat_smooth(method = "lm", se = F) +
scale_color_brewer(palette = "Dark2", direction = -1) +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_y_continuous(labels = label_number()) +
theme_minimal() + guides(color = "none") +
labs(title = "",
y = "População",
x = "Margem de vitória do PP") + scale_x_continuous(labels = label_percent()) + scale_x_continuous(labels = label_percent())
g_densidade_demografica <- dt_todas[densidade_demografica %between% quantile(densidade_demografica, c(.02, .99), na.rm = TRUE)] %>%
ggplot(aes(x = votos_razao_pp_centr, y = densidade_demografica, color = as.factor(vitoria_pp))) +
geom_point(shape = 21, size = 0.5, color = "black") +
stat_smooth(method = "lm", se = F) +
scale_color_brewer(palette = "Dark2", direction = -1) +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_y_continuous(labels = label_number()) +
theme_minimal() + guides(color = "none") +
labs(title = "",
y = "Densidade\ndemográfica",
x = "Margem de vitória do PP") + scale_x_continuous(labels = label_percent())
g_PIBpc <- dt_todas[PIBpc %between% quantile(PIBpc, c(.02, .99), na.rm = TRUE)] %>%
ggplot(aes(x = votos_razao_pp_centr, y = PIBpc, color = as.factor(vitoria_pp))) +
geom_point(shape = 21, size = 0.5, color = "black") +
stat_smooth(method = "lm", se = F) +
scale_color_brewer(palette = "Dark2", direction = -1) +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_y_continuous(labels = label_number()) +
theme_minimal() + guides(color = "none") +
labs(title = "",
y = "PIB per capita",
x = "Margem de vitória do PP") + scale_x_continuous(labels = label_percent())
g_taxa_escolarizacao <- dt_todas[taxa_escolarizacao %between% quantile(taxa_escolarizacao, c(.02, .99), na.rm = TRUE)] %>%
ggplot(aes(x = votos_razao_pp_centr, y = taxa_escolarizacao, color = as.factor(vitoria_pp))) +
geom_point(shape = 21, size = 0.5, color = "black") +
stat_smooth(method = "lm", se = F) +
scale_color_brewer(palette = "Dark2", direction = -1) +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_y_continuous(labels = label_number()) +
theme_minimal() + guides(color = "none") +
labs(title = "",
y = "Taxa de\nescolarização",
x = "Margem de vitória do PP") + scale_x_continuous(labels = label_percent())
plot_grid(g_pop, g_densidade_demografica, g_PIBpc, g_taxa_escolarizacao, ncol = 2)
# Guardar bases de dados completas
dt_todas_completa <- dt_todas
dt_individuais_completa <- dt_individuais
dt_bancada_completa <- dt_bancada
dt_relator_completa <- dt_relator
# Obter janela ótima para modelo linear com covariadas
covariadas <- dt_individuais[, .(pop, densidade_demografica, PIBpc, taxa_escolarizacao)]
janela <- rdbwselect(
x = dt_individuais$votos_razao_pp_centr,
y = dt_individuais$valor_empenhado_ipca_pc,
p = 1,
covs = covariadas
)
janela$bws
# Filtrar base de dados para municípios cuja margem de vitória do PP está na janela
dt_todas <- dt_todas[votos_razao_pp_centr >= -janela$bws[1] &
votos_razao_pp_centr <= janela$bws[1]]
dt_individuais <- dt_individuais[votos_razao_pp_centr >= -janela$bws[1] &
votos_razao_pp_centr <= janela$bws[1]]
dt_bancada <- dt_bancada[votos_razao_pp_centr >= -janela$bws[1] &
votos_razao_pp_centr <= janela$bws[1]]
dt_relator <- dt_relator[votos_razao_pp_centr >= -janela$bws[1] &
votos_razao_pp_centr <= janela$bws[1]]
# Ver quantos municípios com eleições acirradas receberam emendas
writeLines(paste0(
"Quantidade de municípios com eleições acirradas: ",
nrow(dt_todas),
"\nQuantidade de municípios com eleições acirradas que receberam emendas: ",
nrow(dt_todas[valor_empenhado_ipca != 0]),
"\nQuantidade de municípios com eleições acirradas que receberam emendas individuais: ",
nrow(dt_individuais[valor_empenhado_ipca != 0]),
"\nQuantidade de municípios com eleições acirradas que receberam emendas de bancada: ",
nrow(dt_bancada[valor_empenhado_ipca != 0]),
"\nQuantidade de municípios com eleições acirradas que receberam emendas de relator: ",
nrow(dt_relator[valor_empenhado_ipca != 0])))
# Duas regressões lineares com controles de município
regs_lineares_controles <- lm_robust(valor_empenhado_ipca_pc ~ vitoria_pp*votos_razao_pp_centr + regiao + pop + densidade_demografica + PIBpc + taxa_escolarizacao, data = dt_individuais)
#| label: grafico_valor_empenhado_por_razao_votos_pp_linear_com_controles
library(data.table)
library(ggplot2)
library(scales)
# 1) Filtrar como você vinha fazendo
dt_plot <- copy(dt_individuais)[
valor_empenhado_ipca_pc %between% quantile(valor_empenhado_ipca_pc, c(.02, .99), na.rm = TRUE)
]
# 2) Escolher valores de referência para os controles:
# numéricos -> média; categórico (regiao) -> moda (categoria mais frequente)
num_vars <- c("pop", "densidade_demografica", "PIBpc", "taxa_escolarizacao")
cat_var  <- "regiao"
refs <- list()
for (v in num_vars) refs[[v]] <- mean(dt_plot[[v]], na.rm = TRUE)
# modo para regiao
refs[[cat_var]] <- dt_plot[, .N, by = regiao][order(-N)][1, regiao]
# 3) Grid QUEBRADO por lado do cutoff
# lado perdedor (0): só valores < 0
x_left <- seq(min(dt_plot[vitoria_pp == 0]$votos_razao_pp_centr, na.rm = TRUE),
0,
length.out = 200)
grid_left <- data.table(
vitoria_pp = 0,
votos_razao_pp_centr = x_left
)
# lado vencedor (1): só valores > 0
x_right <- seq(0,
max(dt_plot[vitoria_pp == 1]$votos_razao_pp_centr, na.rm = TRUE),
length.out = 200)
grid_right <- data.table(
vitoria_pp = 1,
votos_razao_pp_centr = x_right
)
# adicionar controles aos dois grids
for(v in num_vars){
grid_left[[v]]  <- refs[[v]]
grid_right[[v]] <- refs[[v]]
}
grid_left[[cat_var]]  <- refs[[cat_var]]
grid_right[[cat_var]] <- refs[[cat_var]]
# juntar resultados
newdata_grid <- rbind(grid_left, grid_right)
# certifique-se que fatores no newdata têm os mesmos níveis que no modelo/data
# (se regiao for factor)
if (is.factor(dt_individuais$regiao)) {
newdata_grid[, regiao := factor(regiao, levels = levels(dt_individuais$regiao))]
}
if (is.factor(dt_individuais$vitoria_pp)) {
newdata_grid[, vitoria_pp := factor(vitoria_pp, levels = levels(dt_individuais$vitoria_pp))]
}
# 4) Prever usando o lm que você rodou (gera fit, lwr, upr)
preds <- predict(regs_lineares_controles_grafico,
newdata = newdata_grid,
interval = "confidence", level = 0.95)
newdata_grid[, `:=`(
fit = preds[ , "fit"],
lwr = preds[ , "lwr"],
upr = preds[ , "upr"]
)]
# 5) Plot: pontos reais + linhas preditas (uma por vitoria_pp) + ribbon
ggplot() +
# pontos reais (opcional, com alpha pra não poluir)
geom_point(data = dt_plot, aes(x = votos_razao_pp_centr, y = valor_empenhado_ipca_pc,
color = as.factor(vitoria_pp)),
shape = 21, color = "black", alpha = 0.6, size = 1) +
# linha predita
geom_line(data = newdata_grid,
aes(x = votos_razao_pp_centr, y = fit, color = as.factor(vitoria_pp)),
linewidth = 1.1) +
scale_color_brewer(palette = "Dark2", direction = -1) +
scale_fill_brewer(palette = "Dark2", direction = -1) +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_y_continuous(labels = label_currency(prefix = "R$ ")) +
scale_x_continuous(labels = label_percent()) +
theme_minimal() + guides(color = "none", fill = "none") +
labs(y = "Valor empenhado per capita", x = "Margem de vitória do PP")
# Filtrar base de dados pra região Norte
# Repetir estimação
# Filtrar base de dados pra região Sudeste
# Repetir estimação
# Filtrar base de dados pra região Sul
# Repetir estimação
# Filtrar base de dados pra região Centro-Oeste
# Repetir estimação
# Recuperação das versões completas das bases de dados
dt_todas <- dt_todas_completa
dt_individuais <- dt_individuais_completa
dt_bancada <- dt_bancada_completa
dt_relator <- dt_relator_completa
# Duas regressões lineares sem controles de município
regs_lineares <- lm_robust(valor_empenhado_ipca_pc ~ vitoria_pp*votos_razao_pp_centr, data = dt_individuais)
#| label: grafico_valor_empenhado_por_razao_votos_pp_linear_sem_controles
# 1) Filtrar dados para o gráfico
dt_plot <- copy(dt_individuais)[
valor_empenhado_ipca_pc %between% quantile(valor_empenhado_ipca_pc, c(.02, .99), na.rm = TRUE)
]
# 2) Rodar lm apenas para gerar predições
regs_grafico <- lm(valor_empenhado_ipca_pc ~ vitoria_pp*votos_razao_pp_centr,
data = dt_plot)
# 3) Criar grids separados por lado do cutoff
# esquerda (vitoria_pp = 0)
x_left <- seq(min(dt_plot[vitoria_pp == 0]$votos_razao_pp_centr, na.rm = TRUE),
0,
length.out = 200)
grid_left <- data.table(
vitoria_pp = 0,
votos_razao_pp_centr = x_left
)
# direita (vitoria_pp = 1)
x_right <- seq(0,
max(dt_plot[vitoria_pp == 1]$votos_razao_pp_centr, na.rm = TRUE),
length.out = 200)
grid_right <- data.table(
vitoria_pp = 1,
votos_razao_pp_centr = x_right
)
newdata_grid <- rbind(grid_left, grid_right)
# 4) Previsão das linhas
newdata_grid[, fit := predict(regs_grafico, newdata = newdata_grid)]
# 5) Plot
ggplot() +
geom_point(data = dt_plot,
aes(x = votos_razao_pp_centr, y = valor_empenhado_ipca_pc,
color = as.factor(vitoria_pp)),
shape = 21, color = "black", alpha = 0.6, size = 1) +
geom_line(data = newdata_grid,
aes(x = votos_razao_pp_centr, y = fit, color = as.factor(vitoria_pp)),
linewidth = 1.2) +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_color_brewer(palette = "Dark2", direction = -1) +
scale_y_continuous(labels = scales::label_currency(prefix = "R$")) +
scale_x_continuous(labels = scales::label_percent()) +
theme_minimal() + guides(color = "none") +
labs(x = "Margem de vitória do PP", y = "Valor empenhado per capita")
# Recuperação das versões completas das bases de dados
dt_todas <- dt_todas_completa
dt_individuais <- dt_individuais_completa
dt_bancada <- dt_bancada_completa
dt_relator <- dt_relator_completa
#| label: grafico_caracteristicas_municipais_por_razao_votos_pp_quad
# Recuperação das versões completas das bases de dados
dt_todas <- dt_todas_completa
dt_individuais <- dt_individuais_completa
dt_bancada <- dt_bancada_completa
dt_relator <- dt_relator_completa
# Linear
g_pop <- dt_todas[pop %between% quantile(pop, c(.02, .99), na.rm = TRUE)] %>%
ggplot(aes(x = votos_razao_pp_centr, y = pop, color = as.factor(vitoria_pp))) +
geom_point(shape = 21, size = 0.5, color = "black") +
stat_smooth(method = "lm", se = F, formula = y ~ poly(x, 2)) +
scale_color_brewer(palette = "Dark2", direction = -1) +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_y_continuous(labels = label_number()) +
theme_minimal() + guides(color = "none") +
labs(title = "",
y = "População",
x = "Margem de vitória do PP") + scale_x_continuous(labels = label_percent()) + scale_x_continuous(labels = label_percent())
g_densidade_demografica <- dt_todas[densidade_demografica %between% quantile(densidade_demografica, c(.02, .99), na.rm = TRUE)] %>%
ggplot(aes(x = votos_razao_pp_centr, y = densidade_demografica, color = as.factor(vitoria_pp))) +
geom_point(shape = 21, size = 0.5, color = "black") +
stat_smooth(method = "lm", se = F, formula = y ~ poly(x, 2)) +
scale_color_brewer(palette = "Dark2", direction = -1) +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_y_continuous(labels = label_number()) +
theme_minimal() + guides(color = "none") +
labs(title = "",
y = "Densidade\ndemográfica",
x = "Margem de vitória do PP") + scale_x_continuous(labels = label_percent())
g_PIBpc <- dt_todas[PIBpc %between% quantile(PIBpc, c(.02, .99), na.rm = TRUE)] %>%
ggplot(aes(x = votos_razao_pp_centr, y = PIBpc, color = as.factor(vitoria_pp))) +
geom_point(shape = 21, size = 0.5, color = "black") +
stat_smooth(method = "lm", se = F, formula = y ~ poly(x, 2)) +
scale_color_brewer(palette = "Dark2", direction = -1) +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_y_continuous(labels = label_number()) +
theme_minimal() + guides(color = "none") +
labs(title = "",
y = "PIB per capita",
x = "Margem de vitória do PP") + scale_x_continuous(labels = label_percent())
g_taxa_escolarizacao <- dt_todas[taxa_escolarizacao %between% quantile(taxa_escolarizacao, c(.02, .99), na.rm = TRUE)] %>%
ggplot(aes(x = votos_razao_pp_centr, y = taxa_escolarizacao, color = as.factor(vitoria_pp))) +
geom_point(shape = 21, size = 0.5, color = "black") +
stat_smooth(method = "lm", se = F, formula = y ~ poly(x, 2)) +
scale_color_brewer(palette = "Dark2", direction = -1) +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_y_continuous(labels = label_number()) +
theme_minimal() + guides(color = "none") +
labs(title = "",
y = "Taxa de\nescolarização",
x = "Margem de vitória do PP") + scale_x_continuous(labels = label_percent())
plot_grid(g_pop, g_densidade_demografica, g_PIBpc, g_taxa_escolarizacao, ncol = 2)
# Obter janela ótima para modelo quadrático
### Sem covariadas
janela_outra <- rdbwselect(
x = dt_individuais$votos_razao_pp_centr,
y = dt_individuais$valor_empenhado_ipca_pc,
p = 2
)
janela_outra$bws
### Com covariadas
covariadas <- dt_individuais[, .(pop, densidade_demografica, PIBpc, taxa_escolarizacao)]
janela <- rdbwselect(
x = dt_individuais$votos_razao_pp_centr,
y = dt_individuais$valor_empenhado_ipca_pc,
p = 2,
covs = covariadas
)
janela$bws
# Filtrar base de dados para municípios cuja margem de vitória do PP está na janela
dt_todas <- dt_todas[votos_razao_pp_centr >= -janela$bws[1] &
votos_razao_pp_centr <= janela$bws[1]]
dt_individuais <- dt_individuais[votos_razao_pp_centr >= -janela$bws[1] &
votos_razao_pp_centr <= janela$bws[1]]
dt_bancada <- dt_bancada[votos_razao_pp_centr >= -janela$bws[1] &
votos_razao_pp_centr <= janela$bws[1]]
dt_relator <- dt_relator[votos_razao_pp_centr >= -janela$bws[1] &
votos_razao_pp_centr <= janela$bws[1]]
# Ver quantos municípios com eleições acirradas receberam emendas
writeLines(paste0(
"Quantidade de municípios com eleições acirradas: ",
nrow(dt_todas),
"\nQuantidade de municípios com eleições acirradas que receberam emendas: ",
nrow(dt_todas[valor_empenhado_ipca != 0]),
"\nQuantidade de municípios com eleições acirradas que receberam emendas individuais: ",
nrow(dt_individuais[valor_empenhado_ipca != 0]),
"\nQuantidade de municípios com eleições acirradas que receberam emendas de bancada: ",
nrow(dt_bancada[valor_empenhado_ipca != 0]),
"\nQuantidade de municípios com eleições acirradas que receberam emendas de relator: ",
nrow(dt_relator[valor_empenhado_ipca != 0])))
# Duas regressões quadráticas com controles de município
regs_quad_controles <- lm_robust(valor_empenhado_ipca_pc ~ vitoria_pp*votos_razao_pp_centr + vitoria_pp*votos_razao_pp_centr_sq + regiao + pop + densidade_demografica + PIBpc + taxa_escolarizacao, data = dt_individuais)
#| label: grafico_valor_empenhado_por_razao_votos_pp_quad_com_controles
# 1) Filtrar dados para o gráfico
dt_plot <- copy(dt_individuais)[
valor_empenhado_ipca_pc %between% quantile(valor_empenhado_ipca_pc, c(.02, .99), na.rm = TRUE)
]
# 2) Escolher valores de referência para os controles
num_vars <- c("pop", "densidade_demografica", "PIBpc", "taxa_escolarizacao")
cat_var  <- "regiao"
refs <- list()
for (v in num_vars) refs[[v]] <- mean(dt_plot[[v]], na.rm = TRUE)
refs[[cat_var]] <- dt_plot[, .N, by = regiao][order(-N)][1, regiao]
# 3) Criar grids separados por lado do cutoff
# esquerda (vitoria = 0)
x_left <- seq(min(dt_plot[vitoria_pp == 0]$votos_razao_pp_centr, na.rm = TRUE),
0,
length.out = 200)
grid_left <- data.table(
vitoria_pp = 0,
votos_razao_pp_centr = x_left
)
# direita (vitoria = 1)
x_right <- seq(0,
max(dt_plot[vitoria_pp == 1]$votos_razao_pp_centr, na.rm = TRUE),
length.out = 200)
grid_right <- data.table(
vitoria_pp = 1,
votos_razao_pp_centr = x_right
)
newdata_grid <- rbind(grid_left, grid_right)
# 4) Adicio
#| label: grafico_valor_empenhado_por_razao_votos_pp_quad_com_controles
library(data.table)
library(ggplot2)
library(scales)
# 1) Filtrar dados para o gráfico
dt_plot <- copy(dt_individuais)[
valor_empenhado_ipca_pc %between% quantile(valor_empenhado_ipca_pc, c(.02, .99), na.rm = TRUE)
]
# 2) Escolher valores de referência para os controles
num_vars <- c("pop", "densidade_demografica", "PIBpc", "taxa_escolarizacao")
cat_var  <- "regiao"
refs <- list()
for (v in num_vars) refs[[v]] <- mean(dt_plot[[v]], na.rm = TRUE)
refs[[cat_var]] <- dt_plot[, .N, by = regiao][order(-N)][1, regiao]
# 3) Criar grids separados por lado do cutoff
# esquerda (vitoria = 0)
x_left <- seq(min(dt_plot[vitoria_pp == 0]$votos_razao_pp_centr, na.rm = TRUE),
0,
length.out = 200)
grid_left <- data.table(
vitoria_pp = 0,
votos_razao_pp_centr = x_left
)
# direita (vitoria = 1)
x_right <- seq(0,
max(dt_plot[vitoria_pp == 1]$votos_razao_pp_centr, na.rm = TRUE),
length.out = 200)
grid_right <- data.table(
vitoria_pp = 1,
votos_razao_pp_centr = x_right
)
newdata_grid <- rbind(grid_left, grid_right)
# 4) Adicionar quadrático e controles
newdata_grid[, votos_razao_pp_centr_sq := votos_razao_pp_centr^2]
for(v in num_vars){
newdata_grid[[v]] <- refs[[v]]
}
newdata_grid[[cat_var]] <- refs[[cat_var]]
# Certificar que fatores têm os mesmos níveis
if(is.factor(dt_individuais$regiao)) {
newdata_grid[, regiao := factor(regiao, levels = levels(dt_individuais$regiao))]
}
if(is.factor(dt_individuais$vitoria_pp)) {
newdata_grid[, vitoria_pp := factor(vitoria_pp, levels = levels(dt_individuais$vitoria_pp))]
}
# 5) Criar LM apenas para o gráfico
regs_quad_grafico <- lm(
valor_empenhado_ipca_pc ~ vitoria_pp*votos_razao_pp_centr + vitoria_pp*votos_razao_pp_centr_sq +
regiao + pop + densidade_demografica + PIBpc + taxa_escolarizacao,
data = dt_plot
)
# 6) Previsão
newdata_grid[, fit := predict(regs_quad_grafico, newdata = newdata_grid)]
# 7) Plot final
ggplot() +
geom_point(data = dt_plot,
aes(x = votos_razao_pp_centr, y = valor_empenhado_ipca_pc,
color = as.factor(vitoria_pp)),
shape = 21, color = "black", alpha = 0.6, size = 1) +
geom_line(data = newdata_grid,
aes(x = votos_razao_pp_centr, y = fit, color = as.factor(vitoria_pp)),
linewidth = 1.2) +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_color_brewer(palette = "Dark2", direction = -1) +
scale_y_continuous(labels = scales::label_currency(prefix = "R$")) +
scale_x_continuous(labels = scales::label_percent()) +
theme_minimal() + guides(color = "none") +
labs(x = "Margem de vitória do PP", y = "Valor empenhado per capita")
#| label: grafico_valor_empenhado_por_razao_votos_pp_linear_com_controles
regs_lineares_controles_grafico <- lm(valor_empenhado_ipca_pc ~ vitoria_pp*votos_razao_pp_centr + regiao + pop + densidade_demografica + PIBpc + taxa_escolarizacao, data = dt_individuais)
# 1) Filtrar como você vinha fazendo
dt_plot <- copy(dt_individuais)[
valor_empenhado_ipca_pc %between% quantile(valor_empenhado_ipca_pc, c(.02, .99), na.rm = TRUE)
]
# 2) Escolher valores de referência para os controles:
# numéricos -> média; categórico (regiao) -> moda (categoria mais frequente)
num_vars <- c("pop", "densidade_demografica", "PIBpc", "taxa_escolarizacao")
cat_var  <- "regiao"
refs <- list()
for (v in num_vars) refs[[v]] <- mean(dt_plot[[v]], na.rm = TRUE)
# modo para regiao
refs[[cat_var]] <- dt_plot[, .N, by = regiao][order(-N)][1, regiao]
# 3) Grid QUEBRADO por lado do cutoff
# lado perdedor (0): só valores < 0
x_left <- seq(min(dt_plot[vitoria_pp == 0]$votos_razao_pp_centr, na.rm = TRUE),
0,
length.out = 200)
grid_left <- data.table(
vitoria_pp = 0,
votos_razao_pp_centr = x_left
)
# lado vencedor (1): só valores > 0
x_right <- seq(0,
max(dt_plot[vitoria_pp == 1]$votos_razao_pp_centr, na.rm = TRUE),
length.out = 200)
grid_right <- data.table(
vitoria_pp = 1,
votos_razao_pp_centr = x_right
)
# adicionar controles aos dois grids
for(v in num_vars){
grid_left[[v]]  <- refs[[v]]
grid_right[[v]] <- refs[[v]]
}
grid_left[[cat_var]]  <- refs[[cat_var]]
grid_right[[cat_var]] <- refs[[cat_var]]
# juntar resultados
newdata_grid <- rbind(grid_left, grid_right)
# certifique-se que fatores no newdata têm os mesmos níveis que no modelo/data
# (se regiao for factor)
if (is.factor(dt_individuais$regiao)) {
newdata_grid[, regiao := factor(regiao, levels = levels(dt_individuais$regiao))]
}
if (is.factor(dt_individuais$vitoria_pp)) {
newdata_grid[, vitoria_pp := factor(vitoria_pp, levels = levels(dt_individuais$vitoria_pp))]
}
# 4) Prever usando o lm que você rodou (gera fit, lwr, upr)
preds <- predict(regs_lineares_controles_grafico,
newdata = newdata_grid,
interval = "confidence", level = 0.95)
newdata_grid[, `:=`(
fit = preds[ , "fit"],
lwr = preds[ , "lwr"],
upr = preds[ , "upr"]
)]
# 5) Plot: pontos reais + linhas preditas (uma por vitoria_pp) + ribbon
ggplot() +
# pontos reais (opcional, com alpha pra não poluir)
geom_point(data = dt_plot, aes(x = votos_razao_pp_centr, y = valor_empenhado_ipca_pc,
color = as.factor(vitoria_pp)),
shape = 21, color = "black", alpha = 0.6, size = 1) +
# linha predita
geom_line(data = newdata_grid,
aes(x = votos_razao_pp_centr, y = fit, color = as.factor(vitoria_pp)),
linewidth = 1.1) +
scale_color_brewer(palette = "Dark2", direction = -1) +
scale_fill_brewer(palette = "Dark2", direction = -1) +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_y_continuous(labels = label_currency(prefix = "R$ ")) +
scale_x_continuous(labels = label_percent()) +
theme_minimal() + guides(color = "none", fill = "none") +
labs(y = "Valor empenhado per capita", x = "Margem de vitória do PP")
